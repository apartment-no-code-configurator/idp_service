c
user_params
c
exit
User.find_by(idp_service_id: user_details["_id"].to_s)
User.find_by(idp_service_id: user_details["_id"].to_s).id
user_details
c
user_details["_id"].to_s
user_details["_id"]
user_details["societies"].pluck("aoa_number").include?(aoa_number) && User.find_by(idp_service_id: user_details["_id"]).id
User.all.count
User.all
tenant_establish_connnection
aoa_number = society.aoa_number
@society = Society.find_by(aoa_number: params[:aoa_number])
c
@user_details = MongoDBAdapter.run_query(:fetch_record, {email: params_email, password: params_password}) rescue nil
c
exit
c
params_email
@user_details = MongoDBAdapter.run_query(:fetch_record, {email: params_email, password: params_password}) rescue nil
exit
params_email
c
user_idp_record
c
user_params_idp_details = user_params[:idp_service_details]
user_params[:idp_service_details] = user_params[:idp_service_details][:idp_service_details]
user_params_idp_details = user_params[:idp_service_details][:idp_service_details]
user_params_idp_details = user_params[:idp_service_details]
user_idp_record
c
existing_idp_record = MongoDBAdapter.run_query(:fetch_record, {email: user_params["email"] || user_params[:idp_service_details]["email"]}).first
c
default_user
c
exit
society
default_user
c
existing_idp_record = MongoDBAdapter.run_query(:fetch_record, {email: user_params["email"] || user_params[:idp_service_details]["email"]}).first
c
user_params_idp_details = user_params[:idp_service_details]
existing_idp_record = MongoDBAdapter.run_query(:fetch_record, {email: user_params["email"] || user_params[:idp_service_details]["email"]}).first
c
exit
new_society = {"aoa_number" => society.aoa_number, "profile_id" => user_params_idp_details["profile_id"] }
existing_idp_record["telegram_username"] = user_params_idp_details["telegram_username"]
        existing_idp_record["first_name"] = user_params_idp_details["first_name"]
        existing_idp_record["last_name"] = user_params_idp_details["last_name"]
        existing_idp_record["phone"] = existing_idp_record["phone"] || user_params_idp_details["phone"]
existing_idp_record["telegram_username"] = user_params_idp_details["telegram_username"]
        existing_idp_record["first_name"] = user_params_idp_details["first_name"]
        existing_idp_record["last_name"] = user_params_idp_details["last_name"]
        existing_idp_record["phone"] = existing_idp_record["phone"] | user_params_idp_details["phone"]
user_params_idp_details = user_params[:idp_service_details]
existing_idp_record = MongoDBAdapter.run_query(:fetch_record, {email: user_params["email"] || user_params[:idp_service_details]["email"]}).first
user_params
user_params["email"]
existing_idp_record = MongoDBAdapter.run_query(:fetch_record, {email: user_params["email"]}).first
c
user_idp_record
user_idp_record = update_user_record_idp_values
user_record.save!
c
a1.idp_service_details
a1.telegram_details;
a1 = User.new(set_user_params(user_params))
User.new(set_user_params(user_params))
set_user_params(user_params)
set_user_params(user_params
set_user_params
user_params
c
exit
society
user_record
c
#class Workflow < TenantModel end;
class Workflow < TenantModel end;
class Workflow < TenantModel; end
Workflow.first
User.first
User.all
tenant_establish_connnection if society
@society = Society.find_by(aoa_number: value["aoa_number"])
value.present?
c
value = JsonWebTokenUtils.decode(authorization_token.split("Bearer ")[1]) rescue nil
token
value
value = JsonWebTokenUtils.decode(token.split("Bearer ")[1]) rescue nil
authorization_token = request.headers["Authorization"]
exit
request.headers["aoa_number"]
request.headers["Authorization"]
request.headers
exit
society
c
exit
c
Society.all
c
params
c
exit
Society.first
Society
society
c
Society
exit
c
exit
c
@society = Society.find_by(aoa_number: request.headers["aoa_number"])
request.headers["society_aoa_number"].present?
check_token_access(authorization_token)
@society
authorization_token && check_token_access(authorization_token) && set_society_for_api_requests
request.headers["Authorization"]
c
exit
society
Society
Soceity
Society
Society.connection
Society
user_idp_record = update_user_record_idp_values
user_record
c
exit
c
params
c
JWT.decode token, secret, true, { algorithm: 'HS256' }
JWT.decode token, secret, false, { algorithm: 'HS256' }
JWT.decode token, secret, true, { algorithm: 'HS256' }
secret = "something"
JWT.decode token, secret, true, { algorithm: 'HS256' }
token = token.split("Bearer ")[1]
value = JsonWebTokenUtils.decode(token.split("Bearer ")[1]) 
JWT.decode token, secret, true, { algorithm: 'HS256' }
value = JsonWebTokenUtils.decode(token.split("Bearer ")[1]) 
token
exit
a = a | b1
a = a | b
a = a || b
a = [1,3]
#a.push(b1.uniq.m)
a.push(b1.flatten.uniq)
b1 = [1,2]
b = [1,2]
a = []
user_params[:idp_service_details]
user_record.as_json
user_record
user_params[:idp_service_details]
existing_idp_record = MongoDBAdapter.run_query(:fetch_record, {email: user_params["email"]}).first
MongoDBAdapter.run_query(:fetch_record, {email: "roshanbasu7@gmail.com"}).first
MongoDBAdapter.run_query(:fetch_record, {email: user_params["email"]}).first
user_params
user_record.as_json
user_record
user_params[:idp_service_details]
user_params
c
exit
user_record.as_json
user_record.is_active = true
user_record.as_json
user_record
user_params
c
exit
user_params
user_record.idp_service_id1
user_record.idp_service_id
user_record.idp_service_details
user_record
user
c
params[:user]
user_creation_params
society
$society
c
r1
r1 = user_details.except("password")
user_details
user_details.except("password")
user_details
c
user_obj
@user_obj = UserLib.find_user(params[:idp_user_id])
params
params["idp_service_id"]
params[:idp_service_id]
@user_obj = UserLib.find_user(params[:idp_service_id])
UserLib.find_user 
c
UserLib.methods
(UserLib.class_methods - Object.class_methods).sort
UserLib.find_user 
UserLib
@user_obj = UserLib.find_user(params[:idp_service_id])
c
JsonWebTokenUtils.decode(token.split("Bearer ")[1])
token.split("Bearer ")[1]
token
c
[].first
MongoDBAdapter.run_query(:fetch_record, {_id: idp_id})
MongoDB.run_query(:fetch_record, {_id: idp_id})
MongoDB
idp_id = params[:idp_user_id]
params[:idp_user_id]
params[:user]
params
JsonWebTokenUtils.decode(token.split("Bearer ")[1])
token.split("Bearer ")[1]
token
c
exit
DateTime.now.to_i.to_s
DateTime.now.to_i
DateTime.now
new_society_cache[user_id].eql?(session_id)
new_society_cache[user_id] = "" if new_society_cache[user_id].blank?
new_society_cache[user_id].blank?
new_society_cache = JSON.parse(Cache.sfetch(aoa_number).first)
society_cache.blank?
user_id = user_id.to_s
    society_cache = Cache.sfetch(aoa_number)
Cache.sadd(aoa_number, new_society_cache.to_json)
Cache.delete(aoa_number)
new_society_cache[user_id] = session_id
new_society_cache[user_id].eql?(session_id)
new_society_cache[user_id] = "" if new_society_cache[user_id].blank?
new_society_cache = JSON.parse(Cache.sfetch(aoa_number).first)
society_cache.blank?
user_id = user_id.to_s
    society_cache = Cache.sfetch(aoa_number)
session_id = "testing2"
user_id = 2
Cache.sadd(aoa_number, society_cache)
society_cache = {user_id => session_id}.to_json
society_cache.blank?
society_cache = Cache.sfetch(aoa_number)
user_id = user_id.to_s
session_id = "testing1"
